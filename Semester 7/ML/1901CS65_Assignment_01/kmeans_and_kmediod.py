# -*- coding: utf-8 -*-
"""Kmeans and KMediod.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BxJOnzSjYybayS4cY80iZ2F237ifz9lc

# **K** **MEANS**

# **Libraries Import**
"""

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

#importing Sklearn tools
from sklearn.preprocessing import Normalizer
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn import metrics
from sklearn.metrics import silhouette_score
from sklearn.decomposition import PCA

#importing data viz tools
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
sns.set_style('darkgrid')

import warnings
warnings.filterwarnings("ignore")

# This installation is necessary as we want to do the map view
!pip install -U kaleido

"""# **Dataset Import And Read**"""

# We are reading the data from the given dataset
df= pd.read_csv('/content/Country-data.csv')

#Head gives the value of the top elements, by default it gives top 5 values
# But as we have declared the value to be 10
# It gives us top 10 values
df.head(10)

# It describes the data in various categories
df.describe()

# Gives the info about the type of data and its characteristics
df.info()

# It gives the total boundary of the data
df.shape

"""# **Data Cleaning**"""

df.isnull().sum()

# This indicates that there is no null value in any of the parameters

df.isna().sum()

# As python treats null and na as different, we check both for surity

df['country'].nunique()

# It checks the number of unique countries

final_data=df.drop(['country'],axis=1)
final_data.head()

#As we are suing Unsupervised learning technique we don't need the country column here.So we are going to drop it

"""# **Exploratory Analysis**"""

df.describe()

# Building the correlation matrix using sns heatmap
# It helps us understand the corelation between different parameters.
corr_matrix=final_data.corr()
sns.heatmap(corr_matrix,annot=True,cmap="Greens")

# From the above heatmap:
# gdpp and income,imports and exports,child_mort and total_fert are highly positive correlated
# whereas life_expec and child_mort are highly negative correlated

# Checking the values of different parameters
num_cols= [col for col in df.columns]
num_cols.remove('country')

plt.figure(figsize=(20,20))
i=1
for col in num_cols:
    plt.subplot(5,2,i)
    sns.distplot(df[col])
    i+=1

sns.pairplot(data=df)

#It shows the plot of each pair against each pair

# To represent the data in map view
import kaleido
import plotly.express as px
for parameter in df.drop('country', axis=1).columns:
    fig = px.choropleth(df,
                        locationmode='country names',
                        locations='country',
                        title = parameter + ' per country (World)',color = parameter, color_continuous_scale = "Reds"
                       )

    fig.update_geos(fitbounds="locations", visible=True)
    fig.show(engine='kaleido')

"""# **Data Scaling**"""

#scaling data
scaling=StandardScaler()
scaled=scaling.fit_transform(final_data)

final_scaled_data=pd.DataFrame(scaled,columns=final_data.columns)

# print scaled dataset
final_scaled_data.head()

"""# **Determining the Number Of Clusters**"""

# Determining no of clusters via Elbow Method

arr=[]
K=range(1,10)
for i in K:
    kmean=KMeans(n_clusters=i)
    kmean.fit(final_data)
    arr.append(kmean.inertia_)
    
plt.plot(K,arr,marker='o')
plt.title('Elbow Method',fontsize=15)
plt.xlabel('Number of clusters',fontsize=15)
plt.ylabel('Sum of Squared distance',fontsize=15)
plt.show()

# Determining no of clusters via Sihouette Score
silhouettes={}
inertia = []
range_n_clusters = list(range(2,10,1))
for num_clusters in range_n_clusters:
    kmeans = KMeans(n_clusters=num_clusters, max_iter=60)
    kmeans.fit(final_scaled_data)
    silhouette_avg = silhouette_score(final_scaled_data, kmeans.labels_)
    inertia.append(kmeans.inertia_)
    silhouettes[num_clusters]=silhouette_avg
# plot the SSDs for each n_clusters
# ssd
plt.figure(figsize=(12, 7))
plt.subplot(1,2,1)
plt.plot(range_n_clusters,inertia,color='red')
plt.xlabel('No. of clusters')
plt.ylabel('Inertia')

plt.subplot(1,2,2)
plt.plot(range_n_clusters,np.array(list(silhouettes.values())).astype(float),color='green')
plt.xlabel('No. of clusters')
plt.ylabel('Silhouette score')

print(f'Silhouettes score per cluster: {silhouettes} \n ')

"""# **Implying K Means**"""

#From the above findings we keep the no of clusters as 3
kmeans = KMeans(n_clusters = 3,random_state = 111)
kmeans.fit(final_scaled_data)

# Now we will label the countries
labels_kmeans = kmeans.labels_
labeled_df_kmeans = pd.DataFrame(df)
labeled_df_kmeans['labels'] = labels_kmeans
sns.catplot(x='labels', kind='count', data=labeled_df_kmeans)

"""# **Cluster Visualisation**"""

#Exports vs Imports
sns.scatterplot(labeled_df_kmeans['exports'],labeled_df_kmeans['imports'],hue="labels",data=labeled_df_kmeans) 
plt.title("Exports vs Imports", fontsize=15)
plt.xlabel("Exports", fontsize=12)
plt.ylabel("Imports", fontsize=12)
plt.show()

#Child Mortality vs GDPP
sns.scatterplot(labeled_df_kmeans['child_mort'],labeled_df_kmeans['gdpp'],hue="labels",data=labeled_df_kmeans) 
plt.title("Child Mortality vs GDPP", fontsize=15)
plt.xlabel("Child Mortality", fontsize=12)
plt.ylabel("GDPP", fontsize=12)
plt.show()

#Inflation vs GDPP
sns.scatterplot(labeled_df_kmeans['inflation'],labeled_df_kmeans['gdpp'],hue='labels',data=labeled_df_kmeans) 
plt.title("Inflation vs GDPP", fontsize=15)
plt.xlabel("Inflation", fontsize=12)
plt.ylabel("GDPP", fontsize=12)
plt.show()

# Pairwise plotting of ever pair possible
sns.pairplot(labeled_df_kmeans, hue='labels')
plt.suptitle('Pairwise Comparison', size = 20)
plt.show()

"""From the results abpve we can infer that

- Cluster 0 represents Underdeveloped countries

- Cluster 1 represent Developed Countries

- Cluster 2 represents Developing Countries
"""

# Making a copy of teh dataset
labeled_data = labeled_df_kmeans.copy()

# Labelling the data in the dataset copy
labeled_data['labels'].loc[labeled_data['labels'] == 2 ]= 'Developing Countries'
labeled_data['labels'].loc[labeled_data['labels'] == 1 ]= 'Developed Countries'
labeled_data['labels'].loc[labeled_data['labels'] == 0 ]= 'Under-Developed Countries'

labeled_data.head(10)

# Representing the data on the map to visualize data
fig = px.choropleth(labeled_data[['country','labels']],
                    locationmode = 'country names',
                    locations = 'country',
                    title = 'Country Wise development status (World)',
                    color_discrete_sequence = ["red", "red", "green"], color = labeled_data['labels'], 
                    color_discrete_map = {'Developing Countries':'Yellow',
                                        'Developed Countries':'Green',
                                        'UnderDeveloped Countries':'Red'} )
fig.update_geos(fitbounds = "locations", visible = True)
fig.update_layout(legend_title_text = 'Labels',legend_title_side = 'top',title_pad_l = 260,title_y = 0.86)
fig.show(engine = 'kaleido')

"""# **KMediod**"""

# Installing sckit learn extra for importing Kmediods
!pip install scikit-learn-extra
from sklearn_extra.cluster import KMedoids

# Forming 3 cluster similar to kmeans
kmedoids = KMedoids(n_clusters = 3, random_state = 0)
kmedoids.fit(final_scaled_data)

# Labelling the countries
labels_kmediod = kmedoids.labels_
labeled_df_kmediod = pd.DataFrame(df)
labeled_df_kmediod['labels'] = labels_kmediod
sns.catplot(x='labels', kind='count', data=labeled_df_kmediod)

labeled_data_kmediod = labeled_df_kmediod.copy()

labeled_data_kmediod['labels'].loc[labeled_data_kmediod['labels'] == 2 ]= 'Developing Countries'
labeled_data_kmediod['labels'].loc[labeled_data_kmediod['labels'] == 0 ]= 'Developed Countries'
labeled_data_kmediod['labels'].loc[labeled_data_kmediod['labels'] == 1 ]= 'UnderDeveloped Countries'

labeled_data_kmediod.head(10)

fig = px.choropleth(labeled_data_kmediod[['country','labels']],
                    locationmode='country names',
                    locations='country',
                     title='Country Wise development status (World)',
                     color_discrete_sequence=["orange", "red", "green",'black'],color=labeled_data_kmediod['labels'], 
                    color_discrete_map={'Developing Countries':'Yellow',
                                        'Developed Countries':'Green',
                                        'UnderDeveloped Countries':'Red'} )
fig.update_geos(fitbounds="locations", visible=True)
fig.update_layout(legend_title_text='Labels',legend_title_side='top',title_pad_l=260,title_y=0.86)
fig.show(engine='kaleido')